---
timestamp: 'Thu Oct 16 2025 19:23:59 GMT-0400 (Eastern Daylight Time)'
content_id: 086b839e848989ce249c598ef385b561074229788a1b95bccfc9f9a7a877d495
---

# file: src/concepts/library.ts

```typescript
import { Collection, Db } from "mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Collection prefix to ensure namespace separation
const PREFIX = "Library" + ".";

// Generic types for the concept's external dependencies
type User = ID;
type Book = ID;

// Internal entity types, represented as IDs
type LibraryBook = ID;

/**
 * State: A set of Books with owner, metadata, and Google Cloud storage link.
 */
interface BookDoc {
  _id: LibraryBook;
  ownerId: User;
  title: string;
  totalPages: number;
  storageUrl: string; // URL to Google Cloud storage where PDF is stored
  createdAt: Date;
}

/**
 * @concept Library
 * @purpose Store metadata about books a user owns/reads with links to Google Cloud storage
 */
export default class LibraryConcept {
  books: Collection<BookDoc>;

  constructor(private readonly db: Db) {
    this.books = this.db.collection(PREFIX + "books");
  }

  /**
   * Action: Adds a new book to the user's library.
   * @requires title must be non-empty
   * @requires totalPages > 0
   * @requires storageUrl must be non-empty
   * @effects Inserts a book with link to Google Cloud storage
   */
  async addBook(
    {
      ownerId,
      title,
      totalPages,
      storageUrl,
    }: {
      ownerId: User;
      title: string;
      totalPages: number;
      storageUrl: string;
    },
  ): Promise<{ bookId: LibraryBook } | { error: string }> {
    if (!title || title.trim().length === 0) {
      return { error: "title cannot be empty" };
    }
    if (totalPages <= 0) {
      return { error: "totalPages must be greater than 0" };
    }
    if (!storageUrl || storageUrl.trim().length === 0) {
      return { error: "storageUrl cannot be empty" };
    }

    const bookId = freshID() as LibraryBook;
    await this.books.insertOne({
      _id: bookId,
      ownerId,
      title,
      totalPages,
      storageUrl,
      createdAt: new Date(),
    });

    return { bookId };
  }

  /**
   * Action: Checks if a book exists.
   * @requires Book must exist
   * @effects Returns whether book exists (for tests)
   */
  async getBook(
    { bookId }: { bookId: LibraryBook },
  ): Promise<{ exists: boolean } | { error: string }> {
    const book = await this.books.findOne({ _id: bookId });
    return { exists: !!book };
  }

  /**
   * Action: Lists all books owned by a user.
   * @requires User must exist
   * @effects Returns books owned by user
   */
  async listBooks(
    { ownerId }: { ownerId: User },
  ): Promise<{ bookIds: LibraryBook[] } | { error: string }> {
    const userBooks = await this.books.find({ ownerId }).toArray();
    const bookIds = userBooks.map((book) => book._id);
    return { bookIds };
  }

  /**
   * Action: Removes a book from the user's library.
   * @requires Book must exist and ownerId must match
   * @effects Deletes the book
   */
  async removeBook(
    { ownerId, bookId }: { ownerId: User; bookId: LibraryBook },
  ): Promise<Empty | { error: string }> {
    const book = await this.books.findOne({ _id: bookId });
    if (!book) {
      return { error: "Book not found" };
    }
    if (book.ownerId !== ownerId) {
      return { error: "Book does not belong to user" };
    }

    await this.books.deleteOne({ _id: bookId });
    return {};
  }

  /**
   * Query: Retrieves a book by its ID.
   */
  async _getBook(
    { bookId }: { bookId: LibraryBook },
  ): Promise<BookDoc | null> {
    return await this.books.findOne({ _id: bookId });
  }

  /**
   * Query: Retrieves all books owned by a specific user.
   */
  async _getUserBooks(
    { ownerId }: { ownerId: User },
  ): Promise<BookDoc[]> {
    return await this.books.find({ ownerId }).sort({ createdAt: -1 }).toArray();
  }

  /**
   * Query: Retrieves all books in the library.
   */
  async _getAllBooks(): Promise<BookDoc[]> {
    return await this.books.find({}).sort({ createdAt: -1 }).toArray();
  }
}

```
