# üß≠ Assignment 4a ‚Äî Backend Concept Coding (QuizRead Project Kickoff)

> **Goal:** Implement, test, and document all **QuizRead** backend concepts with **Deno + MongoDB + Context (ctx)** ‚Äî working incrementally, reflectively, and modularly.
>
> **How to use:** Save this file at your repo root as `A4a_Kickoff.md`. Treat it as your project playbook + Cursor prompt library.

---

## 0Ô∏è‚É£ Setup Sanity Checks

* [ ] **Deno installed:** `deno --version`
* [ ] **Compile Context tool:**

  ```bash
  deno compile -A --output ctx .ctx/context.ts
  ```
* [ ] **.env ready:**

  ```ini
  GEMINI_API_KEY=YOUR_KEY_HERE
  GEMINI_MODEL=gemini-2.5-flash
  MONGODB_URL=mongodb+srv://<user>:<pass>@cluster0.mongodb.net/?retryWrites=true&w=majority
  DB_NAME=quizread_dev
  ```
* [ ] **Optional tools:**

  * VS Code + Deno extension
  * Obsidian for Markdown navigation

---

## 1Ô∏è‚É£ Repo Structure (QuizRead)

```
/src/
  /concepts/
    user_auth.ts
    library.ts
    reading_progress.ts
    focus_timer.ts
    checkpoint_quiz.ts
    annotate.ts
  /db/
    client.ts
    collections.ts
  /types/
    ids.ts
  /util/
    errors.ts
    time.ts
/tests/
  user_auth.test.ts
  library.test.ts
  reading_progress.test.ts
  focus_timer.test.ts
  checkpoint_quiz.test.ts
  annotate.test.ts
/design/
  /specs/
    user_auth.md
    library.md
    reading_progress.md
    focus_timer.md
    checkpoint_quiz.md
    annotate.md
  /notes/
    app_design_changes.md
    concept_changes_user_auth.md
    concept_changes_library.md
    concept_changes_reading_progress.md
    concept_changes_focus_timer.md
    concept_changes_checkpoint_quiz.md
    concept_changes_annotate.md
    interesting_moments.md
  /runlogs/
    user_auth_test_output.md
    library_test_output.md
    reading_progress_test_output.md
    focus_timer_test_output.md
    checkpoint_quiz_test_output.md
    annotate_test_output.md
/context/                 # generated by ctx ‚Äî DO NOT EDIT
/.env
/README.md
/A4a_Kickoff.md           # this file
```

---

## 2Ô∏è‚É£ Concept List (finalized for backend)

> Implement **independently**; no cross‚Äëconcept calls or foreign state access. Use **IDs + primitives** only in actions and results.

| # | Concept                  | Responsibility                                                                        |
| - | ------------------------ | ------------------------------------------------------------------------------------- |
| 1 | **UserAuthentication**   | Register/login users; minimal auth state.                                             |
| 2 | **Library**              | Manage user‚Äôs books (title, totalPages, optional content refs).                       |
| 3 | **ReadingProgress**      | Track pages + compute quiz/annotation triggers (booleans).                            |
| 4 | **FocusTimer (generic)** | Pure timer (phase, startedAt, duration, isActive); no user/book knowledge.            |
| 5 | **CheckpointQuiz**       | Generate/store MCQ quizzes **using Gemini API** from recent content; record attempts. |
| 6 | **Annotate**             | Save/list user annotations for content sections.                                      |

> **Note:** Per feedback, **UserAuthentication** and **Library** are added; **FocusTimer** is generalized (no user/book in state). Syncs/orchestration happen in later assignments.

---

## 3Ô∏è‚É£ Specification Templates (use per concept)

Create `/design/specs/<concept>.md` using this structure:

```md
concept <Name> [<Type parameters>]
purpose <one sentence of what this concept does>
principle <short statement of its operational rule>

state
  a set of <EntityPlural> with
    an _id Id
    <field> <Type>

actions
  <actionName> (<arg: Type, ...>) : (<resultName: Type, ...>)
    requires <conditions>
    effect <state change or return semantics>
```

**Rules**

* No composite objects as args/results ‚Äî only **primitives or IDs**.
* No dependencies ‚Äî a concept never reads/writes another concept‚Äôs collections.
* Keep **FocusTimer** generic.

---

## 4Ô∏è‚É£ QuizRead Concept Specs ‚Äî Drafts (paste into `/design/specs/*.md` and refine)

### üßç‚Äç‚ôÇÔ∏è UserAuthentication ‚Äî `/design/specs/user_auth.md`

```md
concept UserAuthentication [User]
purpose authenticate users
principle users must register and log in before using personalized features

state
  a set of Users with
    an _id Id
    an email String
    a passwordHash String
    a createdAt DateTime

actions
  register (email: String, passwordHash: String) : (userId: Id)
    requires email contains "@" and is unique; passwordHash non-empty
    effect inserts new user

  login (email: String, passwordHash: String) : (userId: Id)
    requires user exists and passwordHash matches
    effect returns userId
```

### üìö Library ‚Äî `/design/specs/library.md`

```md
concept Library [User, Book]
purpose store metadata about books a user owns/reads
principle users can add, list, get, and remove their books

state
  a set of Books with
    an _id Id
    an ownerId Id
    a title String
    a totalPages Number
    a createdAt DateTime

actions
  addBook (ownerId: Id, title: String, totalPages: Number) : (bookId: Id)
    requires title non-empty; totalPages > 0
    effect inserts a book

  getBook (bookId: Id) : (exists: Boolean)
    effect returns whether book exists (for tests)

  listBooks (ownerId: Id) : (bookIds: set Id)
    effect returns books owned by user

  removeBook (ownerId: Id, bookId: Id)
    requires book exists and ownerId matches
    effect deletes the book
```

### üìñ ReadingProgress ‚Äî `/design/specs/reading_progress.md`

```md
concept ReadingProgress [User, Book]
purpose track reading state and compute engagement triggers
principle as user advances pages, the concept decides when to trigger quiz/annotation (booleans only)

state
  a set of ReadingSessions with
    an _id Id
    a userId Id
    a bookId Id
    a currentPage Number
    a totalPages Number
    a lastQuizPage Number
    a lastAnnotationPage Number
    a quizInterval Number
    an annotationInterval Number
    a startTime DateTime
    a totalReadingTimeMinutes Number
    an isActive Boolean

actions
  initializeProgress (userId: Id, bookId: Id, totalPages: Number, quizInterval: Number, annotationInterval: Number) : (sessionId: Id)
    requires totalPages > 0; quizInterval > 0; annotationInterval > 0
    effect creates a session with currentPage=1; isActive=true

  updateProgress (sessionId: Id, newPage: Number)
    requires session exists; newPage > currentPage; newPage <= totalPages
    effect sets currentPage=newPage

  triggerQuiz (sessionId: Id) : (shouldTrigger: Boolean)
    effect returns (currentPage - lastQuizPage) >= quizInterval

  triggerAnnotation (sessionId: Id) : (shouldTrigger: Boolean)
    effect returns (currentPage - lastAnnotationPage) >= annotationInterval

  recordQuizTriggered (sessionId: Id)
    requires session exists
    effect sets lastQuizPage = currentPage

  recordAnnotationTriggered (sessionId: Id)
    requires session exists
    effect sets lastAnnotationPage = currentPage

  pauseReading (sessionId: Id)
    requires isActive=true
    effect sets isActive=false and increments totalReadingTimeMinutes by elapsed since startTime

  resumeReading (sessionId: Id)
    requires isActive=false
    effect sets isActive=true and sets startTime=now
```

### ‚è±Ô∏è FocusTimer (generic) ‚Äî `/design/specs/focus_timer.md`

```md
concept FocusTimer []
purpose generic countdown timer with phases
principle when a running timer expires, it flips phase and resets

state
  a set of Timers with
    an _id Id
    a phase String  // "reading" | "break"
    a startedAtMs Number
    a durationMs Number
    an isActive Boolean

actions
  start (durationMs: Number, phase: String) : (timerId: Id)
    requires durationMs > 0; phase in {"reading","break"}
    effect creates active timer

  pause (timerId: Id)
    requires isActive=true
    effect sets isActive=false

  resume (timerId: Id)
    requires isActive=false
    effect sets isActive=true and startedAtMs=now

  system expire (timerId: Id)
    requires isActive=true and (now - startedAtMs) >= durationMs
    effect flips phase (reading‚Üîbreak) and sets startedAtMs=now
```

### ‚úÖ CheckpointQuiz (Gemini-powered) ‚Äî `/design/specs/checkpoint_quiz.md`

```md
concept CheckpointQuiz [User, Content]
purpose generate and evaluate short multiple-choice quizzes to reinforce active reading
principle after N pages, generate a quiz from the recent content and record user attempts

state
  a set of Quizzes with
    an _id Id
    a contentId String
    a question String
    a answers ArrayString  // length >= 2
    a correctIndex Number  // 0-based
    a createdAt DateTime

  a set of QuizAttempts with
    an _id Id
    a userId Id
    a quizId Id
    a selectedIndex Number
    a isCorrect Boolean
    a createdAt DateTime

actions
  generateQuizFromContent (contentId: String, contentText: String) : (quizId: Id)
    effect calls **Gemini** with `contentText` to produce a single MCQ (question, 3‚Äì5 answers, correct index)
           then persists Quizzes and returns quizId

  submitAnswer (userId: Id, quizId: Id, selectedIndex: Number) : (attemptId: Id, isCorrect: Boolean)
    requires quiz exists; 0 <= selectedIndex < answers.length
    effect stores QuizAttempt and returns correctness

notes
  - **LLM provider**: Implementation uses Google **Gemini** (model from `GEMINI_MODEL`).
  - **Testability**: Provide an injectable generator interface; in tests, use a **deterministic stub** to avoid API calls/cost.
  - **Security**: Sanitize/limit `contentText` length to control token usage.
```

### ‚úçÔ∏è Annotate ‚Äî `/design/specs/annotate.md`

```md
concept Annotate [User, Content]
purpose persist reader reflections to encourage active reading
principle prompt users periodically to jot key ideas; store and retrieve annotations

state
  a set of Annotations with
    an _id Id
    a userId Id
    a contentId String
    a text String
    a createdAt DateTime

actions
  saveAnnotation (userId: Id, contentId: String, text: String) : (annotationId: Id)
    requires text non-empty
    effect inserts annotation

  listAnnotations (userId: Id, contentId: String) : (annotationIds: set Id)
    effect returns annotations for user/content ordered by createdAt desc
```

---

## 5Ô∏è‚É£ Minimal DB & Utils (drop‚Äëin stubs)

**`/src/db/client.ts`**

```ts
import { MongoClient } from "npm:mongodb";
let db: any | null = null;
export async function getDb(){
  if (db) return db;
  const url = Deno.env.get("MONGODB_URL");
  const name = Deno.env.get("DB_NAME");
  if (!url || !name) throw new Error("Missing MONGODB_URL or DB_NAME");
  const client = new MongoClient(url);
  await client.connect();
  db = client.db(name);
  return db;
}
```

**`/src/db/collections.ts`**

```ts
import { getDb } from "./client.ts";
export async function users(){ return (await getDb()).collection("users"); }
export async function books(){ return (await getDb()).collection("books"); }
export async function sessions(){ return (await getDb()).collection("reading_sessions"); }
export async function timers(){ return (await getDb()).collection("timers"); }
export async function quizzes(){ return (await getDb()).collection("quizzes"); }
export async function attempts(){ return (await getDb()).collection("quiz_attempts"); }
export async function annotations(){ return (await getDb()).collection("annotations"); }
```

**`/src/types/ids.ts`**

```ts
type Brand<K, T> = K & { __brand: T };
export type UserId = Brand<string, "UserId">;
export type BookId = Brand<string, "BookId">;
export type SessionId = Brand<string, "SessionId">;
export type TimerId = Brand<string, "TimerId">;
export type QuizId = Brand<string, "QuizId">;
export type AttemptId = Brand<string, "AttemptId">;
export type AnnotationId = Brand<string, "AnnotationId">;
export const asId = <T extends string>(s: string) => s as Brand<string, T>;
```

**`/src/util/errors.ts`**

```ts
export class DomainError extends Error { constructor(msg: string){ super(msg); }}
export function requireThat(cond: boolean, msg: string): asserts cond {
  if (!cond) throw new DomainError(msg);
}
```

**`/src/util/time.ts`**

```ts
export const nowMs = () => Date.now();
export const seconds = (n: number) => n * 1000;
export const minutes = (n: number) => seconds(60) * n;
```

---

## 6Ô∏è‚É£ Implementation Order

Implement one concept at a time (spec ‚Üí impl ‚Üí tests):

1. `/design/specs/user_auth.md` ‚Üí `/src/concepts/user_auth.ts` ‚Üí `/tests/user_auth.test.ts`
2. `library` ‚Üí `reading_progress` ‚Üí `focus_timer` ‚Üí `checkpoint_quiz` ‚Üí `annotate`

Run all tests frequently:

```bash
deno fmt && deno lint
deno test -A --fail-fast
```

---

## 7Ô∏è‚É£ Testing Pattern (Deno)

Each test file should include:

* **1 operational principle** test (happy path)
* **3‚Äì5 interesting** scenarios (edge/error cases)
* **Fresh DB** per test file/case (e.g., suffix DB name with a UUID if using one connection helper)
* **Console logs** for clarity (inputs/outputs)

Template:

```ts
import { assertEquals, assertRejects } from "https://deno.land/std/assert/mod.ts";

Deno.test("<Concept> ‚Äî operational principle", async () => {
  console.log("[OP] starting‚Ä¶ inputs=‚Ä¶");
  // Arrange ‚Üí Act ‚Üí Assert
  assertEquals(1, 1);
});

Deno.test("<Concept> ‚Äî interesting: <case>", async () => {
  console.log("[VARIANT] ‚Ä¶");
  await assertRejects(async () => { throw new Error("boom"); });
});
```

> **Policy:** Build state **only by calling actions**. No manual DB seeding.

For **CheckpointQuiz** tests, **inject a deterministic stub** quiz generator (no Gemini calls) to ensure repeatable results and avoid token costs.

---

## 8Ô∏è‚É£ Using Context (ctx) ‚Äî Snapshots for Grading

After each milestone:

```bash
./ctx save design/specs/<concept>.md
./ctx save src/concepts/<concept>.ts
./ctx save tests/<concept>.test.ts
./ctx save design/runlogs/<concept>_test_output.md
```

Never modify `/context` manually.

---

## 9Ô∏è‚É£ Interesting Moments (5‚Äì10)

`/design/notes/interesting_moments.md`

```md
## Moment 1 ‚Äî Generalized FocusTimer
Realized timer leaked app concerns; removed user/book and kept only phase/duration. Cleaner modularity.
@/context/2025-10-16T12-00-00/specs/focus_timer.md
```

Add 5‚Äì10 during development, each with a snapshot link (created via `./ctx save`).

---

## üîü App Design Changes (running doc)

`/design/notes/app_design_changes.md` ‚Äî summarize:

* Added **UserAuthentication** & **Library** per feedback.
* **FocusTimer** generalized.
* **CheckpointQuiz** uses **Gemini** for question generation but exposes a generator interface so tests use a stub.

---

## 1Ô∏è‚É£1Ô∏è‚É£ Cursor Prompt Snippets

**A) Implementation**

```text
You are implementing a modular concept in Deno + MongoDB for QuizRead.
Rules:
- Implement class in /src/concepts/<name>.ts
- Enforce `requires` by throwing DomainError with clear message.
- No cross-concept reads/writes.
- Persist only state fields defined in the spec.
- Return shapes must match the spec exactly.
Task: Read /design/specs/<name>.md and generate a full implementation with typed methods.
```

**B) Tests**

```text
Write Deno tests for /src/concepts/<name>.ts.
Include 1 operational principle test + 3‚Äì5 variant tests.
Build state only via actions. Print clear logs.
Use a fresh database or isolated collections per test.
For CheckpointQuiz, inject a deterministic stub quiz generator (no Gemini calls).
```

**C) CheckpointQuiz (Gemini)**

```text
Implement CheckpointQuiz with an injectable `IQuizGenerator`.
- Default provider uses Google Gemini (env: GEMINI_API_KEY, GEMINI_MODEL) to generate one MCQ (question, 3‚Äì5 answers, correctIndex) from provided `contentText`.
- Tests swap in a deterministic stub generator to avoid network/token costs.
- Validate content length and sanitize user input before calling Gemini.
```

---

## 1Ô∏è‚É£2Ô∏è‚É£ Commands Cheat Sheet

```bash
# Run tests
deno test -A --fail-fast | tee design/runlogs/_last_run.txt

# Snapshot artifacts
./ctx save design/specs/<concept>.md
./ctx save src/concepts/<concept>.ts
./ctx save tests/<concept>.test.ts
./ctx save design/runlogs/<concept>_test_output.md

# Format & lint
deno fmt && deno lint

# Commit & push
git add -A && git commit -m "A4a: <concept> spec+impl+tests" && git push
```

---

## 1Ô∏è‚É£3Ô∏è‚É£ Rubric Checklist ‚úÖ

* **Full Implementation**: all 6 concepts; specs ‚Üî impls match
* **Modularity**: no cross-concept dependencies; IDs/primitives only
* **Principle Tests**: 1 readable OP sequence each
* **Variants**: 3‚Äì5 edge/error tests each
* **Design Changes**: `/design/notes/app_design_changes.md` written
* **Interesting Moments**: 5‚Äì10 with `/context` snapshot links
* **Context Integrity**: `/context` untouched (only via `ctx save`)
* **Submission**: repo pushed + commit hash saved

---

## 1Ô∏è‚É£4Ô∏è‚É£ Suggested Timeline

| Day | Focus                                                        |
| --- | ------------------------------------------------------------ |
| 1   | Specs for all 6 + implement/test UserAuthentication, Library |
| 2   | Implement/test ReadingProgress, FocusTimer                   |
| 3   | Implement/test CheckpointQuiz (with stub), Annotate          |
| 4   | Notes, runlogs, snapshots, quality pass                      |
| 5   | Buffer: polish, commit, push, submit                         |

---

## 1Ô∏è‚É£5Ô∏è‚É£ Gotchas (save hours)

* Pass **IDs only** between concepts; never rich objects.
* Keep **FocusTimer** generic.
* For **CheckpointQuiz**, call **Gemini** only via the provider interface; in tests, always stub.
* Tests must be **programmatic** with clear logs; build state **only via actions**.
* Snapshot early and often; link snapshots in notes for grading.

You‚Äôre ready. Start with `UserAuthentication`: spec ‚Üí impl ‚Üí tests ‚Üí runlogs ‚Üí snapshots ‚Üí log an interesting moment. Then repeat for each concept.
